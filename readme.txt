DV text monitor Ver 3.3  README.txt
DV text monitor Ver 3.3 by JA1XPM 2025/12/24

このプログラムは，ICOM の RS-MS1A / RS-MS1I（スマホ用アプリ）と同じ系統の D-STAR テキスト通信を，Windows PC から行うためのものです．
現在，Windows用で RS-MS1A / RS-MS1I 相当のテキスト通信ソフトが無いため，それを補う目的で作成しました．

主な想定構成：IC-9700(USB(B)) + Windows PC
本プログラムにより，IC-9700 にスマホを接続する必要が無くなり，PC からテキスト送受信が可能になります．

--------------------------------------------------------------------------------
1. 必要なもの
- Windows11 PC(旧バージョンのWindowsは動作確認していない)
- ICOM IC-9700（DV Data I/F (USB(B)を使用）モードはDVモードにする
- リグとPCをUSBケーブルで接続．なお，必要なデバイスドライバはICOMホームページを参照のこと
- PC側のCOMポート番号（例：COM3 など）

※送受信のPTTコントロールは必要ありません．IC-9700はDVデータに設定したUSB(B)にデータを流し込めば自動的に送信される仕様です．

--------------------------------------------------------------------------------
2. 起動方法

2-1) 起動
    python dvtextmonitor.py

2-2) ログファイルに保存したい場合（任意であり，ファイル名は自由）
    python dvtextmonitor.py log.txt

- log は相対パス/絶対パスどちらでも指定可能です．
  例：python dvtextmonir.py C:\temp\dvlog.txt
- ファイルが既にある場合は，起動後に上書き or 追記を選べます．
- ログの文字コードはUTF-8(BOM無し)です．誤ってShift-JIS等の文字コードで保存すると文字が読めなくなります．
--------------------------------------------------------------------------------
3. 設定ファイル dvtextmonitor.ini
起動時，プログラム本体と同じフォルダに dvtextmonitor.ini を探します．

- ini が無い場合：自動で新規作成します（初期値で書きます）
- ini がある場合：内容を読み込んで使用します
  ただし，内容が壊れている場合は「INI FILE ERROR」と表示して終了します

3-1) ini の例（必ずこの4項目のみ）
    COM=COM1
    SPEED=9600
    MY=JA1XPM C
    UR=CQCQCQ

- COM   : COMポート名（例 COM3）
- SPEED : 通信速度（数字）
- MY    : 送信元コール（例 JA1XPM C）
- UR    : 宛先コール（例 W1AW A / CQCQCQ）

※ 起動後コンソールで/MY /UR の各コマンド(後述)で変更しても ini には書き戻しません（ini は復旧用）．
※ SPEED は「数値であること」だけを条件とし，アプリ側で値制限はしませんが，IC-9700のUSB(B)をDVデータにした場合に使える速度は4800か9600だけです．

--------------------------------------------------------------------------------
4. 使い方（基本）
起動すると受信表示が始まります．他の局からRS-MS1A/RS-MS1IでDVテキストが送られてくると表示します．
DV画像を送信したときにテキストメッセージが追加されていた場合，そのメッセージも表示します．(画像データは廃棄)
GNSS形式のGPS情報が付加されている場合はGoogle Map形式のURLで表示します．ctrl+左クリックするとwebブラウザが起動して位置を表示します．
D-PRS形式のGPS情報が付加されている場合は，そのまま表示します．
こちらからコンソールに文字を入力して Enter を押すと相手局に送信します．

4-1) 送信者コールサインMY/宛先コールサインURの切り替え（実行中に可能)
- 現在値表示：
    /MY
    /UR
- 変更：
    /MY JA1XPM C
    /UR W1AW A

※ 大文字/小文字どちらでも入力できます．
※ /MY /UR でコールサインを変更しても ini には書き戻しません．
※ /MYはIC-9700に設定したコールサインと同一にすることを推奨します．
※ 現在のバージョンでは，IC-9700に設定したコールサインをフェッチする機能はありません．

--------------------------------------------------------------------------------
5. よくあるトラブル

5-1) COMポートが開けない
- COM番号が違う
- 他のアプリがCOMを使用中
- 権限/ドライバ問題

この場合，起動時に「Serial Port Error: ...」が表示されます．

5-2) INI FILE ERROR と出て終了する
dvtextmonitor.ini の内容が壊れています．
ini を削除して再起動すると，初期値で再生成します．

--------------------------------------------------------------------------------
6. 終了
Ctrl + C で終了します．
ログにExiting..という文字を残します．異常な終了をした場合は残りません．
--------------------------------------------------------------------------------
免責
本ソフトの使用は自己責任でお願いします．
電波法・各種ルールを守って運用してください．



================================================================================
技術解説（RS-MS1A互換テキスト）
================================================================================

A) RS-MS1A系のテキストパケット構造（$$Msg）
シリアル上で概ね次の形式です（ASCII表現）：

    $$Msg,<MY>,<UR>,<BODY>\r\0

- $$Msg : ヘッダ（ASCII）
- <MY> : 送信者コール（例 JA1XPM C）
- <UR>   : 宛先コール（例 W1AW A, CQCQCQ等）
- <BODY> : 次を連結
    1) ID  : 6バイト固定（ASCII） "0011nn"
    2) TEXT: 本文（RS-MS1A互換のエスケープ後）
    3) CS  : チェックサム（1バイトまたは2バイト）
- 終端   : 0x0D 0x00（CR + NUL）

例：
    $$Msg,JA1XPM C,W1AW A,0011AFaaa#\r\0

--------------------------------------------------------------------------------
B) ID部（6バイト "0011nn"）の生成
IDは 6バイト固定：
    ID = "0011" + nn(2桁16進・大文字)

nn は送信者(MY)と宛先(UR)の両方から計算します．

B-1) コールの分解
"JA1XPM C" は
  BASE   = "JA1XPM"
  SUFFIX = "C"（1文字，無い場合もある）
として扱います．SUFFIXは計算時に lower() します（C→c）．

B-2) 送信側定数 K の計算（UR → K）
    S = sum(ASCII(UR_BASE)) mod 256
    t = ASCII(lower(UR_SUFFIX)) (suffixがあれば) else 0
    K = (S + 0x1A + t) mod 256

B-3) 宛先側 nn の計算（MY → nn）
    U    = sum(ASCII(MY_BASE)) mod 256
    base = (U + K) mod 256
    nn   = base + ASCII(lower(MY_SUFFIX)) (suffixがあれば) を mod 256
    suffixが無ければ nn = base

B-4) 計算例（MY=JA1XPM C / UR=JQ1YZA）
MY: JA1XPM C
  MY_BASE "JA1XPM" の ASCII 和：
    J=74, A=65, 1=49, X=88, P=80, M=77 → 合計 433
    433 mod 256 = 177 = 0xB1
  MY_SUFFIX "C" → lower('c') = 0x63(99)
  K = (0xB1 + 0x1A + 0x63) mod256
    = 177 + 26 + 99 = 302 → 302-256 = 46 = 0x2E

UR: JQ1YZA（suffix無し）
  UR_BASE "JQ1YZA" の ASCII 和：
    J=74, Q=81, 1=49, Y=89, Z=90, A=65 → 合計 448
    448 mod 256 = 192 = 0xC0
  base = (0xC0 + K(0x2E)) mod256 = 0xEE
  suffix無しなので nn = 0xEE

よって ID = "0011EE"

--------------------------------------------------------------------------------
C) テキスト本文は ASCIIまたはUTF-8漢字コード(ただしRS-MS1A互換のエスケープを適用する必要あり)
本文は UTF-8 バイト列として扱います．
ただし実測互換として，本文バイト列中の特定値を送信時に置換（エスケープ）します．
特定値(文末参照)とはD-STAR仕様書で決められています．UTF-8漢字コードにこの特定値が現れる事がありますが，そのままでは通せません．

C-1) 本文エスケープ規則（送信時）
- 0xE7 → 0xEF 0x67
- 0xEF → 0xEF 0x6F

受信時は逆変換：
- 0xEF 0x67 → 0xE7
- 0xEF 0x6F → 0xEF

C-2) エスケープの実例：「画像」
"画像" の raw UTF-8 は：
  "画" U+753B → E7 94 BB
  "像" U+50CF → E5 83 8F
  raw = E7 94 BB E5 83 8F

送信時エスケープ（E7 を置換）：
  E7 94 BB E5 83 8F
  → EF 67 94 BB E5 83 8F

受信時は EF 67 → E7 に戻して元のUTF-8に復元されます．

--------------------------------------------------------------------------------
D) チェックサム（CS）の計算と送信表現
チェックサムは「本文テキストの raw UTF-8 バイト列のみ」を対象に計算します．
（ID部，エスケープ後本文，終端 \r\0 は含めません）

D-1) 計算式（SUM 8bit）
    CS = sum(raw_utf8_bytes) & 0xFF

例：「aaa」
  0x61 + 0x61 + 0x61 = 0x123 → CS = 0x23（'#'）

D-2) CSの送信表現（RS-MS1A互換）
通常は CS を 1バイトで付けますが，実測互換として以下の特例を実装しています：

- CS == 0xEF または CS == 0x2C の場合，2バイト化：
    CS_bytes = 0xEF, (CS + 0x80) & 0xFF
  例：0xEF → EF 6F
  例：0x2C → EF AC

- それ以外は 1バイト：
    CS_bytes = [CS]

D-3) なぜエスケープするか（理由）
メーカー仕様書が無いため断定はできませんが，実測と構造から見ると「衝突回避」が目的と考えるのが自然です（推定）．
- 0xEF は本文側エスケープでも導入バイトとして使われるため，CSが 0xEF のままだと，D-STAR通信使用上ユーザーが使用できないコードのためエスケープしていると思われます．
- 0x2C は ASCII の ','（カンマ）で，$$Msg の区切り文字でもあるため，実装上都合が悪い可能性があります．
重要：確実に言えるのは「RS-MS1Aはその値のときチェックサムを2バイト化して出してくる」という事実で，理由は推定です．

D-4) CSエスケープの実例：テキスト本文が「abcde」
raw（UTF-8/ASCII同じ）:
  61 62 63 64 65

チェックサム:
  0x61+0x62+0x63+0x64+0x65 = 0x1EF → 下位8bit = 0xEF
  よって CS = 0xEF

CSの送信表現（特例により2バイト化）:
  CS_bytes = EF (EF+80 mod256) = EF 6F

よって本文末尾は次のようになります（IDと0x0D,0x00は省略）:
  ... 61 62 63 64 65 EF 6F  ... 

--------------------------------------------------------------------------------
E) 送信の組み立て順（まとめ）
本文 "text" を送る場合の手順：
  1) raw = text.encode("utf-8")
  2) CS = sum(raw) & 0xFF
  3) CS_bytes =（必要なら2バイト化）
  4) payload = 本文エスケープ(raw)
  5) ID = "0011" + nn（MY/URから計算）
  6) BODY = ID + payload + CS_bytes
  7) 最終組み立て(python)packet = b"$$Msg," + UR + b"," + MY + b"," + BODY + b"\r\x00"


================================================================================
技術解説（特定値について）
================================================================================
D-STAR標準方式（JARL STD7.0）の 6.2 簡易データ通信について，**使用できないキャラクター（バイト値）**が明記されています．具体的には次の7個です． 
0x00 (フッター)
0x11（XON） 
0x13（XOFF） 
0x76（パケットロス通知に使用） 
0x84（パケットロス通知に使用） 
0xE7（パケットロス通知に使用） 
0xFE 機能拡張のため予約


